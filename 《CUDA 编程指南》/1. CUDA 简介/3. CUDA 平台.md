
## 1. 计算能力和流式多处理器版本

每一款NVIDIA GPU都有一个计算能力（CC）编号，它表明该GPU支持哪些功能，并规定了该GPU的一些硬件参数。这些规格在[技术附录](https://github.com/akai100/Hello-CUDA/blob/main/%E3%80%8ACUDA%20%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%E3%80%8B/5.%20%E6%8A%80%E6%9C%AF%E9%99%84%E5%BD%95/1.%20%E8%AE%A1%E7%AE%97%E8%83%BD%E5%8A%9B.md)中有详细说明。所有NVIDIA GPU及其计算能力的列表可在CUDA GPU计算能力页面上查询。

计算能力用主版本号和次版本号表示，格式为X.Y，其中X为主版本号，Y为次版本号。例如，CC 12.0的主版本号为12，次版本号为0。计算能力与SM的版本号直接对应。例如，CC 12.0的GPU中的SM具有sm_120版本。此版本用于标记二进制文件。

## 2. CUDA工具包和NVIDIA驱动程序

NVIDIA 驱动程序可以被视为 GPU 的操作系统。NVIDIA 驱动程序是一个软件组件，必须安装在主机系统的操作系统上，是所有 GPU 使用场景（包括显示和图形功能）所必需的。NVIDIA 驱动程序是 CUDA 平台的基础。除了 CUDA 之外，NVIDIA 驱动程序还提供了其他所有使用 GPU 的方法，
例如 Vulkan 和 Direct3D。NVIDIA 驱动程序的版本号如 r580。

CUDA 工具包是一套用于编写、构建和分析利用 GPU 计算的软件的库、头文件和工具。CUDA 工具包是与 NVIDIA 驱动程序分开的软件产品。

CUDA 运行时是 CUDA 工具包提供的库之一的特殊情况。CUDA 运行时提供了 API 和一些语言扩展，用于处理常见任务，如分配内存、在 GPU 与其他 GPU 或 CPU 之间复制数据以及启动内核。CUDA 运行时的 API 组件被称为 CUDA 运行时 API。

### 2.1  CUDA 运行时 API 和 CUDA 驱动 API

CUDA运行时API构建在一个名为CUDA驱动程序API的低级API之上，后者是NVIDIA驱动程序公开的API。本指南重点介绍CUDA运行时API所公开的API。如果需要，仅使用驱动程序API也能实现所有相同的功能。有些功能仅可通过驱动程序API使用。应用程序可以使用其中一种API，
也可以同时使用两种且它们可互操作。CUDA驱动程序API部分介绍了运行时API和驱动程序API之间的互操作。

CUDA 运行时 API 函数的完整 API 参考可在[CUDA 运行时 API 文档]() 中找到。

CUDA 驱动程序 API 的完整 API 参考可在[CUDA 驱动程序 API 文档]()中找到。

## 3. 并行线程执行（PTX）

CUDA平台的一个基础但有时不为人知的层是并行线程执行（PTX）虚拟指令集架构（ISA）。

PTX是NVIDIA GPU的一种高级汇编语言。PTX在真实GPU硬件的物理ISA之上提供了一个抽象层。与其他平台一样，应用程序可以直接用这种汇编语言编写，不过这样做可能会给软件开发带来不必要的复杂性和难度。

特定领域语言和高级语言编译器可以生成PTX代码作为中间表示（IR），然后使用NVIDIA的离线或即时（JIT）编译工具来生成可执行的二进制GPU代码。这使得CUDA平台不仅可以通过NVIDIA提供的工具（如NVCC：NVIDIA CUDA编译器）所支持的语言进行编程，还能通过其他语言实现编程。

由于GPU的性能会随着时间推移发生变化和提升，PTX虚拟ISA规范是有版本区分的。与SM版本类似，PTX版本也对应着一种计算能力。例如，支持计算能力8.0所有特性的PTX被称为compute_80。

关于PTX的完整文档可在[PTX ISA]中找到。

## 4. Cubins 和 Fatbins

CUDA应用程序和库通常是用C++等更高级的语言编写的。这种高级语言会被编译为PTX，然后PTX再被编译为适用于物理GPU的真实二进制文件，这种文件被称为CUDA二进制文件，简称cubin。cubin针对特定的SM版本（如sm_120）具有特定的二进制格式。

使用GPU计算的可执行文件和库二进制文件包含CPU代码和GPU代码。GPU代码存储在一个名为fatbin的容器中。Fatbin可以包含针对多个不同目标的cubin和PTX。

例如，一个应用程序可以使用针对多个不同GPU架构（即不同SM版本）的二进制文件构建。当应用程序运行时，其GPU代码会加载到特定的GPU上，并从fatbin中选用该GPU的最佳二进制文件。

![](https://docs.nvidia.com/cuda/cuda-programming-guide/_images/fatbin.png)

### 4.1 二进制兼容性

NVIDIA GPU在特定情况下保证二进制兼容性。具体而言，在计算能力的主版本内，计算能力次版本大于或等于目标cubin版本的GPU可以加载并执行该cubin。

例如，如果某个应用程序包含为计算能力8.6编译的代码的cubin，那么该cubin可以在计算能力为8.6或8.9的GPU上加载和执行。但是，它不能在计算能力为8.0的GPU上加载，因为该GPU的计算能力次版本0低于代码的次版本6。

NVIDIA GPU在主要计算能力版本之间不具有二进制兼容性。也就是说，为计算能力8.6编译的cubin代码无法在计算能力9.0的GPU上加载。

在讨论二进制代码时，上述示例中的二进制代码通常会被提及具有sm_86这样的版本。这等同于说该二进制代码是为计算能力8.6构建的。这种简写形式经常被使用，因为开发者就是通过这种方式向NVIDIA CUDA编译器nvcc指定该二进制代码的构建目标的。

### 4.2 PTX兼容性

GPU代码可以以二进制或PTX形式存储在可执行文件中，这在二进制文件和胖二进制文件中有介绍。当应用程序存储GPU代码的PTX版本时，该PTX可以在应用程序运行时针对任何等于或高于PTX代码计算能力的计算能力进行**即时编译（JIT编译）**。

例如，如果某个应用程序包含适用于compute_80的PTX，那么该PTX代码可以在应用程序运行时即时编译为更高版本的SM，如sm_120。这实现了与未来GPU的向前兼容性，而无需重新构建应用程序或库。

### 4.3 即时编译

应用程序在运行时加载的PTX代码会由设备驱动程序编译为二进制代码。这被称为即时（JIT）编译。即时编译会增加应用程序的加载时间，但能让应用程序从每个新设备驱动程序带来的任何新编译器改进中获益。它还使应用程序能够在编译时不存在的设备上运行。

当设备驱动程序为应用程序即时编译PTX代码时，它会自动缓存生成的二进制代码副本，以避免在应用程序后续调用时重复编译。这个名为计算缓存的缓存会在设备驱动程序升级时自动失效，这样应用程序就能从设备驱动程序中内置的新型即时编译器的改进中获益。

自CUDA最早的版本以来，PTX在运行时进行即时（JIT）编译的方式和时机就已放宽，这为部分或全部内核的即时编译提供了更多灵活性。延迟加载部分描述了可用的选项以及如何控制即时编译行为。此外，还有一些环境变量可控制即时编译行为，如CUDA环境变量中所述。

作为使用nvcc编译CUDA C++设备代码的替代方案，NVRTC可用于在运行时将CUDA C++设备代码编译为PTX。NVRTC是CUDA C++的运行时编译库，更多信息可参见《NVRTC用户指南》。
